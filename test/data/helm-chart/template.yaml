# yamllint disable rule:line-length
# yamllint disable rule:trailing-spaces
---
# Source: rhtap/templates/developer-hub/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: rhdh-kubernetes-plugin
  namespace: rhtap
---
# Source: rhtap/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: helm-manager
  namespace: rhtap
---
# Source: rhtap/templates/developer-hub/quay-token.yaml
apiVersion: v1
kind: Secret
metadata:
  name: rhdh-pull-secret
data:
  .dockerconfigjson: ${DEVELOPER_HUB__QUAY_TOKEN__ASK_THE_INSTALLER_DEV_TEAM}
type: kubernetes.io/dockerconfigjson
---
# Source: rhtap/templates/developer-hub/serviceaccount.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: rhdh-kubernetes-plugin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
  - kind: ServiceAccount
    name: rhdh-kubernetes-plugin
    namespace: rhtap
---
# Source: rhtap/templates/serviceaccount.yaml
# The ServiceAccount needs to be able to manage resources that
# might not be declated until after Subscriptions have been
# deployed (e.g. TektonConfig).
#
# If the ServiceAccount did not have admin privilegers, it
# would need the permission to edit roles. An attacker
# getting access to this ServiceAccount would be able
# to grant any role to any account.
# Therefore the attack surface is not increased by giving
# the admin role to the ServiceAccount.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: helm-manager-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: helm-manager
    namespace: rhtap
---
# Source: rhtap/templates/openshift-gitops/subscription.yaml
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-gitops-operator
  namespace: openshift-operators
spec:
  channel: gitops-1.11
  installPlanApproval: Automatic
  name: openshift-gitops-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  config:
    env:
      - name: ARGOCD_CLUSTER_CONFIG_NAMESPACES
        value: openshift-gitops,rhtap
---
# Source: rhtap/templates/openshift-pipelines/subscription.yaml
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-pipelines-operator
  namespace: openshift-operators
spec:
  channel: pipelines-1.14
  installPlanApproval: Automatic
  name: openshift-pipelines-operator-rh
  source: redhat-operators
  sourceNamespace: openshift-marketplace
---
# Source: rhtap/templates/trusted-artifact-signer/subscription.yaml
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  labels:
    operators.coreos.com/rhtas-operator.openshift-operators: ""
  name: rhtas-operator
  namespace: openshift-operators
spec:
  channel: stable
  installPlanApproval: Automatic
  name: rhtas-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  startingCSV: rhtas-operator.v0.0.2
---
# Source: rhtap/templates/configure.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "rhtap-installer-configure"
  labels:
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/instance: "installer"
    app.kubernetes.io/version: 2.1.0
    helm.sh/chart: "rhtap-0.9.4"
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    "helm.sh/hook": post-install, post-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      name: "installer-configure"
      labels:
        app.kubernetes.io/managed-by: "Helm"
        app.kubernetes.io/instance: "installer"
        helm.sh/chart: "rhtap-0.9.4"
    spec:
      containers:
      
                
        - name: configure-acs
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
            
        
                    
              echo -n "* Waiting for openshift-pipelines: "
              while ! kubectl get namespace openshift-pipelines --ignore-not-found > /dev/null; do
                echo -n "."
                sleep 2
              done
              echo "OK"
              
              CRDS=( pipelines tasks )
              for CRD in "${CRDS[@]}"; do
                echo -n "* Waiting for '$CRD' CRD: "
                while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                  echo -n "."
                  sleep 2
                done
                echo "OK"
              done
              
              echo -n "* Waiting for openshift-pipelines webhook service: "
              while true; do
                # Try instanciating a task
                cat << EOF | kubectl apply -f - --dry-run=server >/dev/null 2>&1 && break
              apiVersion: tekton.dev/v1
              kind: Task
              metadata:
                name: deleteme-task
              spec:
                description: >-
                  Test task to validate that Tekton is installed.
                steps:
                  - image: "k8s.gcr.io/hyperkube:v1.12.1"
                    name: setup
                    script: |
                      #!/usr/bin/env bash
                      echo "OK"
                    workingDir: /tmp
              EOF
                echo -n "."
                sleep 2
              done
              echo "OK"
              
        
              echo -n "* Configuring Tasks: "
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: acs-deploy-check
                spec:
                  description: >-
                    Policy check a deployment with StackRox/RHACS This tasks allows you to check
                    a deployment against build-time policies and apply enforcement to fail
                    builds. It's a companion to the stackrox-image-scan task, which returns full
                    vulnerability scan results for an image.
                  params:
                    - default:  "${ACS__CENTRAL_ENDPOINT}"
                      description: |
                        Secret containing the address:port tuple for StackRox Central
                        (example - rox.stackrox.io:443)
                      name: rox_central_endpoint
                      type: string
                    - default: "${ACS__API_TOKEN}"
                      description: |
                        Secret containing the StackRox API token with CI permissions
                      name: rox_api_token
                      type: string
                    - description: |
                        URL to the deployment
                        (example - https://raw.gitlab.mycompany.com/myorg/myapp/mybranch/argocd/mycomponent/myenv/deployment.yaml)
                      name: deployment_url
                      type: string
                    - default: 'false'
                      description: |
                        When set to \`"true"\`, skip verifying the TLS certs of the Central
                        endpoint.  Defaults to \`"false"\`.
                      name: insecure-skip-tls-verify
                      type: string
                  results:
                    - description: Output of \`roxctl deployment check\`
                      name: check_output
                  steps:
                    - env:
                      - name: ROX_API_TOKEN
                        value: \$(params.rox_api_token)
                      - name: ROX_ENDPOINT
                        value: \$(params.rox_central_endpoint)
                      image: registry.access.redhat.com/ubi8/ubi-minimal
                      name: rox-deploy-scan
                      script: |
                        #!/usr/bin/env bash
                        set -o errexit
                        set -o nounset
                        set -o pipefail
                
                        curl -s -k -L -H "Authorization: Bearer \$ROX_API_TOKEN" \
                          "https://\$ROX_ENDPOINT/api/cli/download/roxctl-linux" \
                          --output ./roxctl  \
                          > /dev/null
                        chmod +x ./roxctl  > /dev/null
                
                        curl --fail --insecure --location --output deployment.yaml --silent "\$(params.deployment_url)"
                
                        ./roxctl deployment check \
                          \$(
                            [ "\$(params.insecure-skip-tls-verify)" = "true" ] && \
                            echo -n "--insecure-skip-tls-verify"
                          ) \
                          --file "deployment.yaml" \
                          --output json > check.log
                          cat check.log
                      workingDir: /tmp
                
              EOF
              echo -n "."
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: acs-image-check
                spec:
                  description: |
                    Policy check an image with StackRox/RHACS This tasks allows you to
                    check an image against build-time policies and apply enforcement to fail builds.
                    It's a companion to the acs-image-scan task, which returns full vulnerability
                    scan results for an image.
                  params:
                  - default: "${ACS__CENTRAL_ENDPOINT}"
                    description: |
                      Secret containing the address:port tuple for StackRox Central
                      (example - rox.stackrox.io:443)
                    name: rox_central_endpoint
                    type: string
                  - default: "${ACS__API_TOKEN}"
                    description: |
                      Secret containing the StackRox API token with CI permissions
                    name: rox_api_token
                    type: string
                  - description: |
                      Full name of image to scan (example -- gcr.io/rox/sample:5.0-rc1)
                    name: image
                    type: string
                  - default: "false"
                    description: |
                      When set to \`"true"\`, skip verifying the TLS certs of the Central
                      endpoint.  Defaults to \`"false"\`.
                    name: insecure-skip-tls-verify
                    type: string
                  - description: |
                      Digest of the image
                    name: image_digest
                    type: string
                  results:
                  - description: Output of \`roxctl image check\`
                    name: check_output
                  steps:
                  - env:
                    - name: ROX_API_TOKEN
                      value: \$(params.rox_api_token)
                    - name: ROX_ENDPOINT
                      value: \$(params.rox_central_endpoint)
                    image: registry.access.redhat.com/ubi8/ubi-minimal
                    name: rox-image-check
                    workingDir: /tmp
                    script: |
                      #!/usr/bin/env bash
                      set -o errexit
                      set -o nounset
                      set -o pipefail
                      set -x
                
                      # Install roxctl
                      curl --fail --insecure --location --silent \
                        --header "Authorization: Bearer \$ROX_API_TOKEN" \
                        --output ./roxctl  \
                        "https://\$ROX_ENDPOINT/api/cli/download/roxctl-linux" \
                        > /dev/null
                      chmod +x ./roxctl  > /dev/null
                
                      # Check image
                      IMAGE=\$(params.image)@\$(params.image_digest)
                      ./roxctl image scan --force \
                        \$(
                          [ "\$(params.insecure-skip-tls-verify)" = "true" ] && \
                          echo -n "--insecure-skip-tls-verify"
                        ) \
                        --image "\$IMAGE" \
                        --output json > check.log
                
                      cat check.log
                
              EOF
              echo -n "."
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: acs-image-scan
                spec:
                  description: |
                    Retrun a full vulnerability scan results for an image.
                  params:
                  - default: "${ACS__CENTRAL_ENDPOINT}"
                    description: |
                      Secret containing the address:port tuple for StackRox Central
                      (example - rox.stackrox.io:443)
                    name: rox_central_endpoint
                    type: string
                  - default: "${ACS__API_TOKEN}"
                    description: |
                      Secret containing the StackRox API token with CI permissions
                    name: rox_api_token
                    type: string
                  - description: |
                      Full name of image to scan (example -- gcr.io/rox/sample:5.0-rc1)
                    name: image
                    type: string
                  - default: "false"
                    description: |
                      When set to \`"true"\`, skip verifying the TLS certs of the Central
                      endpoint.  Defaults to \`"false"\`.
                    name: insecure-skip-tls-verify
                    type: string
                  - description: |
                      Digest of the image
                    name: image_digest
                    type: string
                  results:
                  - description: Output of \`roxctl image check\`
                    name: check_output
                  steps:
                  - env:
                    - name: ROX_API_TOKEN
                      value: \$(params.rox_api_token)
                    - name: ROX_ENDPOINT
                      value: \$(params.rox_central_endpoint)
                    image: registry.access.redhat.com/ubi8/ubi-minimal
                    name: rox-image-check
                    workingDir: /tmp
                    script: |
                      #!/usr/bin/env bash
                      set -o errexit
                      set -o nounset
                      set -o pipefail
                      set -x
                
                      # Install roxctl
                      curl --fail --insecure --location --silent \
                        --header "Authorization: Bearer \$ROX_API_TOKEN" \
                        --output ./roxctl  \
                        "https://\$ROX_ENDPOINT/api/cli/download/roxctl-linux" \
                        > /dev/null
                      chmod +x ./roxctl  > /dev/null
                
                      # Scan image
                      IMAGE=\$(params.image)@\$(params.image_digest)
                      ./roxctl image scan --force \
                        \$(
                          [ "\$(params.insecure-skip-tls-verify)" = "true" ] && \
                          echo -n "--insecure-skip-tls-verify"
                        ) \
                        --image "\$IMAGE" \
                        --output json > scan.log
                
                      cat scan.log
                
              EOF
              echo -n "."
              echo "OK"
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-developer-hub
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
            
        
        
              # Installing Helm...
              curl --fail --silent --show-error --location \
                https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 \
                  | bash
        
              YQ_VERSION="v4.40.5"
              curl --fail --location --output "/usr/bin/yq" --silent --show-error "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
              chmod +x "/usr/bin/yq"
        
              CHART="rhtap"
              NAMESPACE="rhtap"
        
              echo -n "* Generating values.yaml: "
              HELM_VALUES="/tmp/developer-hub-values.yaml"
            
              cat <<EOF >${HELM_VALUES}
              global:
                dynamic:
                  includes:
                  - dynamic-plugins.default.yaml
                  plugins:
                  - disabled: false
                    package: ./dynamic-plugins/dist/roadiehq-backstage-plugin-argo-cd
                    pluginConfig:
                      dynamicPlugins:
                        frontend:
                          roadiehq.backstage-plugin-argo-cd:
                            mountPoints:
                            - config:
                                if:
                                  allOf:
                                  - isArgocdAvailable
                                layout:
                                  gridColumnEnd:
                                    lg: span 8
                                    xs: span 12
                              importName: EntityArgoCDOverviewCard
                              mountPoint: entity.page.overview/cards
                            - config:
                                if:
                                  allOf:
                                  - isArgocdAvailable
                                layout:
                                  gridColumn: 1 / -1
                              importName: EntityArgoCDHistoryCard
                              mountPoint: entity.page.cd/cards
                  - disabled: false
                    package: ./dynamic-plugins/dist/roadiehq-backstage-plugin-argo-cd-backend-dynamic
                  - disabled: false
                    package: ./dynamic-plugins/dist/roadiehq-scaffolder-backend-argocd-dynamic
                  - disabled: false
                    package: ./dynamic-plugins/dist/backstage-plugin-techdocs-backend-dynamic
                  - disabled: false
                    package: ./dynamic-plugins/dist/backstage-plugin-techdocs
                  - disabled: false
                    package: ./dynamic-plugins/dist/backstage-plugin-kubernetes
                  - disabled: false
                    package: ./dynamic-plugins/dist/backstage-plugin-kubernetes-backend-dynamic
                    pluginConfig:
                      kubernetes:
                        clusterLocatorMethods:
                        - clusters:
                          - authProvider: serviceAccount
                            name: rhdh-kubernetes-plugin
                            serviceAccountToken: <token>
                            skipTLSVerify: true
                            url: https://kubernetes.default.svc
                          type: config
                        customResources:
                        - apiVersion: v1
                          group: route.openshift.io
                          plural: routes
                        - apiVersion: v1
                          group: tekton.dev
                          plural: pipelineruns
                        - apiVersion: v1
                          group: tekton.dev
                          plural: taskruns
                        serviceLocatorMethod:
                          type: multiTenant
                  - disabled: false
                    package: ./dynamic-plugins/dist/janus-idp-backstage-plugin-quay
                  - disabled: false
                    package: ./dynamic-plugins/dist/janus-idp-backstage-plugin-tekton
                    pluginConfig:
                      dynamicPlugins:
                        frontend:
                          janus-idp.backstage-plugin-tekton:
                            mountPoints:
                            - config:
                                if:
                                  allOf:
                                  - isTektonCIAvailable
                                layout:
                                  gridColumn: 1 / -1
                                  gridRowStart: 1
                              importName: TektonCI
                              mountPoint: entity.page.ci/cards
                  - disabled: false
                    package: ./dynamic-plugins/dist/janus-idp-backstage-plugin-topology
              EOF
            
              echo "OK"
        
              
              ################################################################################
              # Tekton plugin configuration
              ################################################################################
              export K8S_SA_TOKEN=$(
                SECRET_NAME=$(kubectl get secrets --namespace "$NAMESPACE" -o name | grep rhdh-kubernetes-plugin-token- | cut -d/ -f2 | head -1)
                kubectl get secret --namespace "$NAMESPACE" "$SECRET_NAME" -o jsonpath={.data.token} | base64 -d
              )
              yq -i '
                (
                  (
                    (.global.dynamic.plugins[] | select(.package == "./dynamic-plugins/dist/backstage-plugin-kubernetes-backend-dynamic")) |
                    .pluginConfig.kubernetes.clusterLocatorMethods[].clusters[]
                  ) |
                  select(.name == "rhdh-kubernetes-plugin") |
                  .serviceAccountToken
                ) = strenv(K8S_SA_TOKEN)
              ' "$HELM_VALUES"
              
        
              echo -n "* Installing Developer Hub: "
              helm repo add developer-hub https://raw.githubusercontent.com/rhdh-bot/openshift-helm-charts/rhdh-1.1-rhel-9/installation
              echo -n "."
              if ! helm upgrade \
                --install \
                --devel \
                --namespace=${NAMESPACE} \
                --values="$HELM_VALUES" \
                developer-hub \
                developer-hub/developer-hub; then
                echo "ERROR while installing chart!"
                exit 1
              fi
              echo "OK"
        
              
              ################################################################################
              # Configure TLS
              ################################################################################
              echo -n "* Waiting for deployment: "
              until kubectl get deployment developer-hub -o name >/dev/null ; do
                echo -n "."
                sleep 3
              done
              echo "OK"
              
              echo -n "* Configure TLS:"
              PATCH="/tmp/configure_tls.patch.json"
              cat << EOF >"$PATCH"
              [
                  {
                      "op": "add",
                      "path": "/spec/template/spec/containers/0/env/-",
                      "value": {
                          "name": "NODE_EXTRA_CA_CERTS",
                          "value": "/ingress-cert/ca.crt"
                      }
                  },
                  {
                      "op": "add",
                      "path": "/spec/template/spec/containers/0/volumeMounts/-",
                      "value": {
                          "name": "kube-root-ca",
                          "mountPath": "/ingress-cert"
                      }
                  },
                  {
                      "op": "add",
                      "path": "/spec/template/spec/volumes/-",
                      "value": {
                          "name": "kube-root-ca",
                          "configMap": {
                              "name": "kube-root-ca.crt",
                              "defaultMode": 420
                          }
                      }
                  }
              ]
              EOF
              echo -n "."
              oc patch deployment/developer-hub --namespace "$NAMESPACE" --type=json --patch-file="$PATCH" >/dev/null
              echo "OK"
              
        
              echo -n "* Waiting for route: "
              until kubectl get route "developer-hub" -o name >/dev/null ; do
                echo -n "."
                sleep 3
              done
              HOSTNAME="$(kubectl get routes "developer-hub" -o jsonpath="{.spec.host}")"
              echo -n "."
              if [ "$(kubectl get secret "$CHART-developer-hub-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                kubectl create secret generic "$CHART-developer-hub-secret" \
                  --from-literal="hostname=$HOSTNAME" >/dev/null
              fi
              echo "OK"
        
              echo -n "* Updating app-config.yaml: "
              kubectl get configmap developer-hub-app-config -o yaml > developer-hub-app-config.current.yaml
              yq '.data.["app-config.yaml"]' developer-hub-app-config.current.yaml > app-config.yaml
              touch app-config-update.yaml
              echo -n "."
        
              # Set the base URL
              URL="https://$HOSTNAME"
              yq -i ".app.baseUrl = \"$URL\" | .backend.baseUrl = \"$URL\" |.backend.cors.origin = \"$URL\"" app-config.yaml
              echo -n "."
        
            
              cat << _EOF_ >> app-config-update.yaml
              auth:
                environment: development
                providers:
                  github:
                    development:
                      clientId: ${GITHUB__APP__CLIENT_ID}
                      clientSecret: ${GITHUB__APP__CLIENT_SECRET}
              catalog:
                locations:
                - target: ${DEVELOPER_HUB__CATALOG__URL}
                  type: url
                rules:
                - allow:
                  - Component
                  - System
                  - Group
                  - Resource
                  - Location
                  - Template
                  - API
              integrations:
                github:
                - apps:
                  - appId: ${GITHUB__APP__APP_ID}
                    clientId: ${GITHUB__APP__CLIENT_ID}
                    clientSecret: ${GITHUB__APP__CLIENT_SECRET}
                    privateKey: |
                      ${GITHUB__APP__PRIVATE_KEY}
                    webhookSecret: ${GITHUB__APP__WEBHOOK_SECRET}
                    webhookUrl: GITHUB__APP__WEBHOOK_URL
                  host: github.com
              techdocs:
                builder: local
                generator:
                  runIn: local
                publisher:
                  type: local
              _EOF_
              echo -n "."
            
        
              # ArgoCD integration
              while [ "$(kubectl get secret "$CHART-argocd-secret" --ignore-not-found -o name | wc -l)" != "1" ]; do
                echo -ne "_"
                sleep 2
              done
              kubectl get secret "$CHART-argocd-secret" -o yaml > argocd_secret.yaml
              echo -n "."
        
              ARGOCD_API_TOKEN="$(yq '.data.api-token | @base64d' argocd_secret.yaml)"
              ARGOCD_HOSTNAME="$(yq '.data.hostname | @base64d' argocd_secret.yaml)"
              ARGOCD_PASSWORD="$(yq '.data.password | @base64d' argocd_secret.yaml)"
              ARGOCD_USER="$(yq '.data.user | @base64d' argocd_secret.yaml)"
              cat << _EOF_ >> app-config-update.yaml
              argocd:
                username: $ARGOCD_USER
                password: $ARGOCD_PASSWORD
                waitCycles: 25
                appLocatorMethods:
                  - type: 'config'
                    instances:
                      - name: default
                        url: https://$ARGOCD_HOSTNAME
                        token: $ARGOCD_API_TOKEN
              _EOF_
        
              # Tekton integration
              while [ "$(kubectl get secret "$CHART-pipelines-secret" --ignore-not-found -o name | wc -l)" != "1" ]; do
                echo -ne "_"
                sleep 2
              done
              PIPELINES_PAC_URL="$(kubectl get secret "$CHART-pipelines-secret" -o yaml | yq '.data.webhook-url | @base64d')"
              yq -i ".integrations.github[0].apps[0].webhookUrl = \"$PIPELINES_PAC_URL\"" app-config-update.yaml
              echo -n "."
        
              # Process app-config update
              yq -i '. *= load("app-config-update.yaml")' app-config.yaml
              yq ".data.[\"app-config.yaml\"] = \"$(cat app-config.yaml | sed 's:":\\":g')\"" developer-hub-app-config.current.yaml > developer-hub-app-config.new.yaml
              if [ "$(md5sum developer-hub-app-config.current.yaml | cut -d' ' -f1)" != "$(md5sum developer-hub-app-config.new.yaml | cut -d' ' -f1)" ]; then
                echo
                kubectl apply -f developer-hub-app-config.new.yaml
                echo "OK"
                echo -n "* Restarting Developer Hub: "
                ##################################################
                # This should help with DB migration issues.
                # Ultimately this should be a bug on DH, as the node could go down
                # unexpectedly when the pod starts.
                #
                until curl --fail --insecure --location --output /dev/null --silent "$URL"; do
                  echo -n "_"
                  sleep 3
                done
                echo -n "."
                for _ in $(seq 1 20); do
                  echo -n "_"
                  sleep 3
                done
                #
                ##################################################
                kubectl delete pods -l "app.kubernetes.io/component=backstage" >/dev/null
              fi
              echo "OK"
        
              echo -n "* Waiting for UI: "
              until curl --fail --insecure --location --output /dev/null --silent "$URL"; do
                echo -n "_"
                sleep 3
              done
              echo "OK"
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-gitops
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/sh
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
            
        
              echo -n "* Installing 'argocd' CLI: "
              curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
              chmod 555 argocd
              ./argocd version --client | head -1 | cut -d' ' -f2
        
              CRD="argocds"
              echo -n "* Waiting for '$CRD' CRD: "
              while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              #
              # All actions must be idempotent
              #
              CHART="rhtap"
              ARGOCD_NAMESPACE="openshift-gitops"
        
              echo -n "* Waiting for gitops operator deployment: "
              until kubectl get argocd -n "$ARGOCD_NAMESPACE" openshift-gitops --ignore-not-found >/dev/null; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              RHTAP_ARGOCD_NAMESPACE="rhtap"
              RHTAP_ARGOCD_INSTANCE="rhtap-argocd"
        
              echo -n "* Creating ArgoCD instance for RHTAP: "
              cat <<EOF | kubectl apply -n "${RHTAP_ARGOCD_NAMESPACE}" -f -
                    
              ---
              apiVersion: argoproj.io/v1beta1
              kind: ArgoCD
              metadata:
                name: rhtap-argocd
              spec:
                server:
                  autoscale:
                    enabled: false
                  grpc:
                    ingress:
                      enabled: false
                  ingress:
                    enabled: false
                  resources:
                    limits:
                      cpu: 500m
                      memory: 256Mi
                    requests:
                      cpu: 125m
                      memory: 128Mi
                  route:
                    enabled: true
                    tls:
                      insecureEdgeTerminationPolicy: Redirect
                      termination: reencrypt
                  service:
                    type: ''
                grafana:
                  enabled: false
                  ingress:
                    enabled: false
                  resources:
                    limits:
                      cpu: 500m
                      memory: 256Mi
                    requests:
                      cpu: 250m
                      memory: 128Mi
                  route:
                    enabled: false
                monitoring:
                  enabled: false
                notifications:
                  enabled: false
                prometheus:
                  enabled: false
                  ingress:
                    enabled: false
                  route:
                    enabled: false
                initialSSHKnownHosts: {}
                sso:
                  dex:
                    openShiftOAuth: true
                    resources:
                      limits:
                        cpu: 500m
                        memory: 256Mi
                      requests:
                        cpu: 250m
                        memory: 128Mi
                  provider: dex
                applicationSet:
                  resources:
                    limits:
                      cpu: '2'
                      memory: 1Gi
                    requests:
                      cpu: 250m
                      memory: 512Mi
                  webhookServer:
                    ingress:
                      enabled: false
                    route:
                      enabled: false
                rbac:
                  defaultPolicy: ''
                  policy: |
                    g, system:cluster-admins, role:admin
                    g, cluster-admins, role:admin
                  scopes: '[groups]'
                repo:
                  resources:
                    limits:
                      cpu: '1'
                      memory: 1Gi
                    requests:
                      cpu: 250m
                      memory: 256Mi
                resourceExclusions: |
                  - apiGroups:
                    - tekton.dev
                    clusters:
                    - '*'
                    kinds:
                    - TaskRun
                    - PipelineRun
                ha:
                  enabled: false
                  resources:
                    limits:
                      cpu: 500m
                      memory: 256Mi
                    requests:
                      cpu: 250m
                      memory: 128Mi
                tls:
                  ca: {}
                redis:
                  resources:
                    limits:
                      cpu: 500m
                      memory: 256Mi
                    requests:
                      cpu: 250m
                      memory: 128Mi
                controller:
                  processors: {}
                  resources:
                    limits:
                      cpu: '2'
                      memory: 2Gi
                    requests:
                      cpu: 250m
                      memory: 1Gi
                extraConfig:
                  accounts.admin: apiKey, login
              
              EOF
        
              echo -n "* ArgoCD dashboard: "
              test_cmd="kubectl get route -n "${RHTAP_ARGOCD_NAMESPACE}" "${RHTAP_ARGOCD_INSTANCE}-server" --ignore-not-found -o jsonpath={.spec.host}"
              ARGOCD_HOSTNAME="$(${test_cmd})"
              until curl --fail --insecure --output /dev/null --silent "https://$ARGOCD_HOSTNAME"; do
                echo -n "."
                sleep 2
                ARGOCD_HOSTNAME="$(${test_cmd})"
              done
              echo "OK"
        
              echo -n " * ArgoCD admin user: "
              if [ "$(kubectl get secret "$CHART-argocd-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                  ARGOCD_PASSWORD="$(kubectl get secret -n "${RHTAP_ARGOCD_NAMESPACE}" "${RHTAP_ARGOCD_INSTANCE}-cluster" -o jsonpath="{.data.admin\.password}" | base64 --decode)"
                  ./argocd login "$ARGOCD_HOSTNAME" --grpc-web --insecure --username admin --password "$ARGOCD_PASSWORD" >/dev/null
                  echo -n "."
                  ARGOCD_API_TOKEN="$(./argocd account generate-token --account "admin")"
                  echo -n "."
                  kubectl create secret generic "$CHART-argocd-secret" \
                    --from-literal="api-token=$ARGOCD_API_TOKEN" \
                    --from-literal="hostname=$ARGOCD_HOSTNAME" \
                    --from-literal="password=$ARGOCD_PASSWORD" \
                    --from-literal="user=admin" \
                    > /dev/null
              fi
              echo "OK"
        
                    
              echo -n "* Waiting for openshift-pipelines: "
              while ! kubectl get namespace openshift-pipelines --ignore-not-found > /dev/null; do
                echo -n "."
                sleep 2
              done
              echo "OK"
              
              CRDS=( pipelines tasks )
              for CRD in "${CRDS[@]}"; do
                echo -n "* Waiting for '$CRD' CRD: "
                while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                  echo -n "."
                  sleep 2
                done
                echo "OK"
              done
              
              echo -n "* Waiting for openshift-pipelines webhook service: "
              while true; do
                # Try instanciating a task
                cat << EOF | kubectl apply -f - --dry-run=server >/dev/null 2>&1 && break
              apiVersion: tekton.dev/v1
              kind: Task
              metadata:
                name: deleteme-task
              spec:
                description: >-
                  Test task to validate that Tekton is installed.
                steps:
                  - image: "k8s.gcr.io/hyperkube:v1.12.1"
                    name: setup
                    script: |
                      #!/usr/bin/env bash
                      echo "OK"
                    workingDir: /tmp
              EOF
                echo -n "."
                sleep 2
              done
              echo "OK"
              
        
              echo -n "* Configuring Tasks: "
              cat << EOF | kubectl apply -f - >/dev/null
                    
              apiVersion: tekton.dev/v1
              kind: Task
              metadata:
                name: argocd-login-check
              spec:
                description: >-
                  Check the argocd login credentials.
                steps:
                  - env:
                    - name: ARGOCD_HOSTNAME
                      valueFrom:
                        secretKeyRef:
                          name: rhtap-argocd-secret
                          key: hostname
                    - name: ARGOCD_PASSWORD
                      valueFrom:
                        secretKeyRef:
                          name: rhtap-argocd-secret
                          key: password
                    - name: ARGOCD_USER
                      valueFrom:
                        secretKeyRef:
                          name: rhtap-argocd-secret
                          key: user
                    image: registry.access.redhat.com/ubi9/ubi-minimal
                    name: check-argocd-login
                    script: |
                      #!/usr/bin/env bash
                      set -o errexit
                      set -o nounset
                      set -o pipefail
              
                      echo -n "* Installing 'argocd' CLI: "
                      curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                      chmod 555 argocd
                      ./argocd version --client | head -1 | cut -d' ' -f2
              
                      ./argocd login "\$ARGOCD_HOSTNAME" --grpc-web --insecure --username "\$ARGOCD_USER" --password "\$ARGOCD_PASSWORD"
                    workingDir: /tmp
              
              EOF
              echo "OK"
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-namespace
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
            
        
                    
              echo -n "* Waiting for openshift-pipelines: "
              while ! kubectl get namespace openshift-pipelines --ignore-not-found > /dev/null; do
                echo -n "."
                sleep 2
              done
              echo "OK"
              
              CRDS=( pipelines tasks )
              for CRD in "${CRDS[@]}"; do
                echo -n "* Waiting for '$CRD' CRD: "
                while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                  echo -n "."
                  sleep 2
                done
                echo "OK"
              done
              
              echo -n "* Waiting for openshift-pipelines webhook service: "
              while true; do
                # Try instanciating a task
                cat << EOF | kubectl apply -f - --dry-run=server >/dev/null 2>&1 && break
              apiVersion: tekton.dev/v1
              kind: Task
              metadata:
                name: deleteme-task
              spec:
                description: >-
                  Test task to validate that Tekton is installed.
                steps:
                  - image: "k8s.gcr.io/hyperkube:v1.12.1"
                    name: setup
                    script: |
                      #!/usr/bin/env bash
                      echo "OK"
                    workingDir: /tmp
              EOF
                echo -n "."
                sleep 2
              done
              echo "OK"
              
        
              echo -n "* Configuring Tasks: "
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: rhtap-dev-namespace-setup
                  annotations:
                    helm.sh/chart: "rhtap-0.9.4"
                spec:
                  description: >-
                    Create the required resources for rhtap tasks to run in a namespace.
                  params:
                    - default: \${GITOPS__GIT_TOKEN}
                      description: |
                        Git token
                      name: git_token
                      type: string
                    - default: \${QUAY__TOKEN}
                      description: |
                        Image registry token
                      name: quay_token
                      type: string
                    - default: \${ACS__CENTRAL_ENDPOINT}
                      description: |
                        StackRox Central address:port tuple
                        (example - rox.stackrox.io:443)
                      name: acs_central_endpoint
                      type: string
                    - default: \${ACS__API_TOKEN}
                      description: |
                        StackRox API token with CI permissions
                      name: acs_api_token
                      type: string
                  steps:
                    - env:
                      - name: GIT_TOKEN
                        value: \$(params.git_token)
                      - name: QUAY_TOKEN
                        value: \$(params.quay_token)
                      - name: ROX_API_TOKEN
                        value: \$(params.acs_api_token)
                      - name: ROX_ENDPOINT
                        value: \$(params.acs_central_endpoint)
                      image: "quay.io/codeready-toolchain/oc-client-base:latest"
                      name: setup
                      script: |
                        #!/usr/bin/env bash
                        set -o errexit
                        set -o nounset
                        set -o pipefail
                      
                
                        SECRET_NAME="gitops-auth-secret"
                        if [ -n "\$GIT_TOKEN" ]; then
                          echo -n "* \$SECRET_NAME secret: "
                          kubectl create secret generic "\$SECRET_NAME" \
                            --from-literal=password=\$GIT_TOKEN \
                            --type=kubernetes.io/basic-auth \
                            --dry-run=client -o yaml | kubectl apply --filename - --overwrite=true >/dev/null
                          kubectl annotate secret "\$SECRET_NAME" "helm.sh/chart=rhtap-0.9.4" >/dev/null
                          echo "OK"
                        fi
                        
                        SECRET_NAME="rhtap-image-registry-token"
                        if [ -n "\$QUAY_TOKEN" ]; then
                          echo -n "* \$SECRET_NAME secret: "
                          DATA=$(mktemp)
                          echo -n "\$QUAY_TOKEN" | base64 -d >"\$DATA"
                          kubectl create secret docker-registry "\$SECRET_NAME" \
                            --from-file=.dockerconfigjson="\$DATA" --dry-run=client -o yaml | \
                            kubectl apply --filename - --overwrite=true >/dev/null
                          rm "\$DATA"
                          echo -n "."
                          kubectl annotate secret "\$SECRET_NAME" "helm.sh/chart=rhtap-0.9.4" >/dev/null
                          echo -n "."
                          while ! kubectl get serviceaccount pipeline >/dev/null &>2; do
                            sleep 2
                            echo -n "_"
                          done
                          kubectl patch serviceaccounts pipeline --patch "
                        secrets:
                          - name: \$SECRET_NAME
                        imagePullSecrets:
                          - name: \$SECRET_NAME
                        " >/dev/null
                          echo "OK"
                          kubectl get serviceaccount pipeline -o yaml
                        fi
                        
                        SECRET_NAME="rox-api-token"
                        if [ -n "\$ROX_API_TOKEN" ] && [ -n "\$ROX_ENDPOINT" ]; then
                          echo -n "* \$SECRET_NAME secret: "
                          kubectl create secret generic "\$SECRET_NAME" \
                            --from-literal=rox_central_endpoint=\$ROX_ENDPOINT \
                            --from-literal=rox_api_token=\$ROX_API_TOKEN \
                            --dry-run -o yaml | kubectl apply --filename - --overwrite=true >/dev/null
                          kubectl annotate secret "\$SECRET_NAME" "helm.sh/chart=rhtap-0.9.4" >/dev/null
                          echo "OK"
                        fi
                
                        echo "Namespace is ready to execute rhtap pipelines"
                      workingDir: /tmp
                
              EOF
              echo -n "."
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: rhtap-pe-info
                  annotations:
                    helm.sh/chart: "rhtap-0.9.4"
                spec:
                  description: >-
                    Display the configuration information needed by the Platform
                    Engineer to configure the RHDH.
                  steps:
                    - env:
                      - name: ARGOCD_HOSTNAME
                        valueFrom:
                          secretKeyRef:
                            name: rhtap-argocd-secret
                            key: hostname
                      - name: ARGOCD_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: rhtap-argocd-secret
                            key: api-token
                      - name: DEVELOPER_HUB_HOSTNAME
                        valueFrom:
                          secretKeyRef:
                            name: rhtap-developer-hub-secret
                            key: hostname
                      - name: PIPELINES_PAC_GH_SECRET
                        valueFrom:
                          secretKeyRef:
                            name: rhtap-pipelines-secret
                            key: webhook-github-secret
                      - name: PIPELINES_PAC_URL
                        valueFrom:
                          secretKeyRef:
                            name: rhtap-pipelines-secret
                            key: webhook-url
                      image: "k8s.gcr.io/hyperkube:v1.12.1"
                      name: setup
                      script: |
                        #!/usr/bin/env bash
                        set -o errexit
                        set -o nounset
                        set -o pipefail
                
                        # Output information in YAML so that it can easily be
                        # post-processed if necessary.
                        cat << _EOF_
                        gitops:
                          api-token: \$ARGOCD_TOKEN
                          hostname: \$ARGOCD_HOSTNAME
                        developer-hub:
                          hostname: \$DEVELOPER_HUB_HOSTNAME
                        pipelines:
                          pipelines-as-code:
                            github:
                              # The docs URL explains how to setup the GitHub Application.
                              # Set dummy values for the homepage URL and webhook URL, and
                              # replace them with the final values after the chart is installed.
                              docs-url: https://pipelinesascode.com/docs/install/github_apps/
                              homepage-url: https://\$DEVELOPER_HUB_HOSTNAME
                              callback-url: https://\$DEVELOPER_HUB_HOSTNAME/api/auth/github/handler/frame
                              webhook-url: \$PIPELINES_PAC_URL
                              secret: \$PIPELINES_PAC_GH_SECRET
                        _EOF_
                      workingDir: /tmp
                
              EOF
              echo -n "."
              echo "OK"
        
            
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-pipelines
          image: quay.io/redhat-appstudio/appstudio-utils:dbbdd82734232e6289e8fbae5b4c858481a7c057
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
            
        
              CRD="tektonconfigs"
              echo -n "* Waiting for '$CRD' CRD: "
              while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              #
              # All actions MUST be idempotent
              #
              CHART="rhtap"
              PIPELINES_NAMESPACE="openshift-pipelines"
        
              echo -n "* Waiting for pipelines operator deployment: "
              until kubectl get namespace "$PIPELINES_NAMESPACE" >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              until kubectl get route -n "$PIPELINES_NAMESPACE" pipelines-as-code-controller >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              echo -n "* Update the TektonConfig resource: "
              until kubectl get tektonconfig config >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              kubectl patch tektonconfig config --type 'merge' --patch '        
                {
                  "spec": {
                    "pipeline": {
                      "enable-bundles-resolver": true,
                      "enable-cluster-resolver": true,
                      "enable-custom-tasks": true,
                      "enable-git-resolver": true,
                      "enable-hub-resolver": true,
                      "enable-tekton-oci-bundles": true
                    },
                    "chain": {
                      "artifacts.oci.storage": "oci",
                      "artifacts.pipelinerun.format": "in-toto",
                      "artifacts.pipelinerun.storage": "oci",
                      "artifacts.taskrun.format": "in-toto",
                      "artifacts.taskrun.storage": "oci",
                      "transparency.enabled": "true",
                      "transparency.url": "http://rekor-server.rekor.svc"
                    }
                  }
                }
                ' >/dev/null
              echo "OK"
        
              echo -n "* Configuring Chains secret: "
              SECRET="signing-secrets"
              if [ "$(kubectl get secret -n "$PIPELINES_NAMESPACE" "$SECRET" -o jsonpath='{.data}' --ignore-not-found --allow-missing-template-keys)" == "" ]; then
                # Delete secret/signing-secrets if already exists since by default cosign creates immutable secrets
                echo -n "."
                kubectl delete secrets  -n "$PIPELINES_NAMESPACE" "$SECRET" --ignore-not-found=true
        
                # To make this run conveniently without user input let's create a random password
                echo -n "."
                RANDOM_PASS=$( openssl rand -base64 30 )
        
                # Generate the key pair secret directly in the cluster.
                # The secret should be created as immutable.
                echo -n "."
                env COSIGN_PASSWORD=$RANDOM_PASS cosign generate-key-pair "k8s://$PIPELINES_NAMESPACE/$SECRET" >/dev/null
              fi
              # If the secret is not marked as immutable, make it so.
              if [ "$(kubectl get secret -n "$PIPELINES_NAMESPACE" "$SECRET" -o jsonpath='{.immutable}')" != "true" ]; then
                echo -n "."
                kubectl patch secret -n "$PIPELINES_NAMESPACE" "$SECRET" --dry-run=client -o yaml \
                  --patch='{"immutable": true}' \
                | kubectl apply -f - >/dev/null
              fi
              echo "OK"
        
            
              echo -n "* Configuring Pipelines-as-Code: "
              if [ "$(kubectl get secret "$CHART-pipelines-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                echo -n "."
                WEBHOOK_SECRET="\${GITHUB__APP__WEBHOOK_SECRET}"
                kubectl create secret generic "$CHART-pipelines-secret" \
                  --from-literal="webhook-github-secret=$WEBHOOK_SECRET" \
                  --from-literal="webhook-url=$(kubectl get routes -n "$PIPELINES_NAMESPACE" pipelines-as-code-controller -o jsonpath="https://{.spec.host}")" >/dev/null
              else
                WEBHOOK_SECRET="$(kubectl get secret "$CHART-pipelines-secret" ) -o jsonpath="{.data.webhook-github-secret}" | base64 -d"
              fi
              if [ "$(kubectl get secret -n "$PIPELINES_NAMESPACE" "pipelines-as-code-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                echo -n "."
                kubectl -n "$PIPELINES_NAMESPACE" create secret generic pipelines-as-code-secret \
                  --from-literal github-application-id="${GITHUB__APP__APP_ID}" \
                  --from-literal github-private-key="$(echo "JHtHSVRIVUJfX0FQUF9fUFJJVkFURV9LRVl9Cg==" | base64 -d)" \
                  --from-literal webhook.secret="$WEBHOOK_SECRET" \
                  --dry-run=client -o yaml | kubectl apply -f - >/dev/null
              fi
              echo "OK"
            
        
              echo
              echo "Configuration successful"
        
                
        
        - name: configure-trusted-artifact-signer
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
          
        
              CHART="rhtap"
        
              echo -n "* Configure OIDC: "
            
              git clone https://github.com/securesign/sigstore-ocp.git >/dev/null
              echo -n "."
              oc apply --kustomize sigstore-ocp/keycloak/operator/base
              echo -n "."
              for CR in keycloaks keycloakclients keycloakrealms keycloakusers; do
                while [ $(kubectl api-resources | grep -c "^$CR ") = "0" ] ; do
                  echo -n "_"
                  sleep 2
                done
                echo -n "."
              done
              oc apply --kustomize sigstore-ocp/keycloak/resources/base --dry-run=client -o yaml
              oc apply --kustomize sigstore-ocp/keycloak/resources/base
              echo -n "."
              export FULCIO__OIDC__CLIENT_ID="trusted-artifact-signer"
              export FULCIO__OIDC__TYPE="email"
              FULCIO__OIDC__URL=""
              while [ -z "$FULCIO__OIDC__URL" ]; do
                FULCIO__OIDC__URL="$(kubectl get routes -n keycloak-system keycloak -o jsonpath="{.spec.host}" --ignore-not-found)"
                sleep 2
              done
              export FULCIO__OIDC__URL="https://$FULCIO__OIDC__URL/auth/realms/trusted-artifact-signer"
            
              export FULCIO__ORG_EMAIL="${TAS__SECURESIGN__FULCIO__ORG_EMAIL}"
              export FULCIO__ORG_NAME="${TAS__SECURESIGN__FULCIO__ORG_NAME}"
              echo "OK"
        
              CRDS=( securesigns )
              for CRD in "${CRDS[@]}"; do
                echo -n "* Waiting for '$CRD' CRD: "
                while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                  echo -n "_"
                  sleep 2
                done
                echo "OK"
              done
        
              echo -n "* Configure SecureSign instance: "
              cat <<EOF | kubectl apply -f - >/dev/null
              
              apiVersion: rhtas.redhat.com/v1alpha1
              kind: Securesign
              metadata:
                name: rhtap-securesign
                labels:
                  app.kubernetes.io/instance: securesign-sample
                  app.kubernetes.io/name: securesign-sample
                  app.kubernetes.io/part-of: trusted-artifact-signer
                namespace: rhtap
              spec:
                fulcio:
                  certificate:
                    commonName: fulcio.hostname
                    organizationEmail: ${FULCIO__ORG_EMAIL}
                    organizationName: ${FULCIO__ORG_NAME}
                  config:
                    OIDCIssuers:
                      "${FULCIO__OIDC__URL}":
                        ClientID: ${FULCIO__OIDC__CLIENT_ID}
                        IssuerURL: "${FULCIO__OIDC__URL}"
                        Type: ${FULCIO__OIDC__TYPE}
                  externalAccess:
                    enabled: true
                  monitoring: false
                rekor:
                  externalAccess:
                    enabled: true
                  signer:
                    kms: secret
                  monitoring: false
                trillian:
                  database:
                    create: true
                tuf:
                  externalAccess:
                    enabled: true
                  keys:
                    - name: rekor.pub
                    - name: ctfe.pub
                    - name: fulcio_v1.crt.pem
                  port: 80
              
              EOF
              echo "OK"
        
              echo
              echo "Configuration successful"
        
        
                
        
        - name: configure-trusted-profile-analyzer
          image: quay.io/codeready-toolchain/oc-client-base:latest
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
          
        
              cd /tmp
        
              # Installing Helm...
              curl --fail --silent --show-error --location \
                https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 \
                  | bash
              
              # Storing the attributes ".trusted-profile-analyzer" from "values.yaml" as a
              # standalone file, employed later on as input for the trustification Charts.
              declare -r TRUSTIFICATION_VALUES="/tmp/trustification-values.yaml"
          
              cat <<EOF >${TRUSTIFICATION_VALUES}
              ---
              eventBus:
                bootstrapServers: tpa-infrastructure-kafka:9092
                config:
                  mechanism: PLAIN
                  password:
                    valueFrom:
                      secretKeyRef:
                        key: client-passwords
                        name: tpa-infrastructure-kafka-user-passwords
                  securityProtocol: SASL_PLAINTEXT
                  username: user1
                type: kafka
              guac:
                database:
                  host: tpa-infrastructure-postgresql
                  name: guac
                  password: ${TPA__GUAC__PASSWORD}
                  sslMode: disable
                  username: guac
                initDatabase:
                  host: tpa-infrastructure-postgresql
                  name: postgres
                  password:
                    valueFrom:
                      secretKeyRef:
                        key: postgres-password
                        name: tpa-infrastructure-postgresql
                  sslMode: disable
                  username: postgres
              ingress:
                className: openshift-default
              kafka:
                controller:
                  containerSecurityContext:
                    enabled: false
                  podSecurityContext:
                    enabled: false
                enabled: true
                kraft:
                  clusterId: 3nA2qspzReOmcxqlkmITAA
                provisioning:
                  containerSecurityContext:
                    enabled: false
                  podSecurityContext:
                    enabled: false
              keycloak:
                auth:
                  adminPassword: ${TPA__KEYCLOAK__ADMIN_PASSWORD}
                  adminUser: admin
                containerSecurityContext:
                  enabled: false
                enabled: true
                ingress:
                  annotations:
                    route.openshift.io/termination: reencrypt
                  enabled: true
                  ingressClassName: openshift-default
                  servicePort: https
                podSecurityContext:
                  enabled: false
                postgresql:
                  auth:
                    password: ${TPA__POSTGRES__TPA_PASSWORD}
                    postgresPassword: ${TPA__POSTGRES__POSTGRES_PASSWORD}
                    username: trusted-profile-analyzer
                  primary:
                    containerSecurityContext:
                      enabled: false
                    podSecurityContext:
                      enabled: false
                production: true
                proxy: reencrypt
                service:
                  annotations:
                    service.beta.openshift.io/serving-cert-secret-name: sso-tls
                tls:
                  enabled: true
                  existingSecret: sso-tls
                  usePem: true
              minio:
                containerSecurityContext:
                  enabled: false
                enabled: true
                podSecurityContext:
                  enabled: false
                rootPassword: ${TPA__MINIO__ROOT_PASSWORD}
              modules:
                bombasticWalker:
                  sources:
                    redhat:
                      acceptV3Signatures: true
                      fixLicenses: true
                      job:
                        schedule: 0 * * * *
                      signingKeyUrl: https://access.redhat.com/security/data/97f5eac4.txt#77E79ABE93673533ED09EBE2DCE3823597F5EAC4
                      url: https://access.redhat.com/security/data/sbom/beta/
                vexinationWalker:
                  sources:
                    redhat:
                      acceptV3Signatures: true
                      ignoreDistributions:
                      - https://access.redhat.com/security/data/csaf/v2/advisories/
                      job:
                        schedule: 0 * * * *
                      url: https://www.redhat.com/.well-known/csaf/provider-metadata.json
              oidc:
                clients:
                  frontend: {}
                  testingManager:
                    clientSecret:
                      value: ${TPA__OIDC__TESTING_MANAGER_CLIENT_SECRET}
                  testingUser:
                    clientSecret:
                      value: ${TPA__OIDC__TESTING_USER_CLIENT_SECRET}
                  walker:
                    clientSecret:
                      value: ${TPA__OIDC__WALKER_CLIENT_SECRET}
              openshift:
                useServiceCa: true
              storage:
                accessKey:
                  valueFrom:
                    secretKeyRef:
                      key: root-user
                      name: tpa-infrastructure-minio
                endpoint: http://tpa-infrastructure-minio:9000
                secretKey:
                  valueFrom:
                    secretKeyRef:
                      key: root-password
                      name: tpa-infrastructure-minio
              tracing:
                enabled: false
              EOF
          
        
              # Same namespace where the "rhtap" is being released
              declare -r NAMESPACE="rhtap"
              # Primary openshift domain name, other apps will be exposed via wildcards
              declare -r INGRESS_DOMAIN=$(
                  oc --namespace=openshift-ingress-operator \
                    get ingresscontrollers.operator.openshift.io default \
                      --output=jsonpath='{.status.domain}'
              )
              # suffix for applications with a fully qualified domain
              declare -r APP_DOMAIN="-${NAMESPACE}.${INGRESS_DOMAIN}"
        
              # Cloning the trustification repository, and resetting to a known commit
              # before rollout.
              git clone https://github.com/trustification/trustification.git
              pushd trustification &&
                # Desired commit for trustification charts.
                git reset --hard 9abcf0a6 &&
                  # Adding the bitnami repository for "trustification-infrastructure"
                  # dependencies.
                  helm repo add bitnami https://charts.bitnami.com/bitnami
        
                  # Preparing Helm dependencies for both charts...
                  pushd deploy/k8s/charts/trustification-infrastructure &&
                    helm dependency build
                  popd
                  pushd deploy/k8s/charts/trustification &&
                    helm dependency build
                  popd
        
                  pushd deploy/k8s &&
                    # Installing the infrastructure needed for trustification first, and
                    # only when infrastructure is ready the trustification rollout
                    # starts...
                    if ! helm upgrade \
                      --install \
                      --namespace=${NAMESPACE} \
                      --timeout=10m \
                      --values=${TRUSTIFICATION_VALUES} \
                      --set-string=keycloak.ingress.hostname=sso${APP_DOMAIN} \
                      --set-string=appDomain=${APP_DOMAIN} \
                      --debug \
                      tpa-infrastructure \
                      charts/trustification-infrastructure; then
                      echo "ERROR: Installing trustification-infrastructure chart!"
                      exit 1
                    fi
                  
                    if ! helm upgrade \
                        --install \
                        --namespace=${NAMESPACE} \
                        --timeout=10m \
                        --values=${TRUSTIFICATION_VALUES} \
                        --set-string=keycloak.ingress.hostname=sso${APP_DOMAIN} \
                        --set-string appDomain=${APP_DOMAIN} \
                        --debug \
                        tpa \
                        charts/trustification; then
                      echo "ERROR: Installing trustification chart!"
                      exit 1
                    fi
                  popd
              popd
              echo "OK"
        
              echo
              echo "Configuration successful"
        
        
      restartPolicy: Never
      serviceAccountName: helm-manager
---
# Source: rhtap/templates/test.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "rhtap-installer-test"
  labels:
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/instance: "installer"
    app.kubernetes.io/version: 2.1.0
    helm.sh/chart: "rhtap-0.9.4"
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    helm.sh/hook: test
spec:
  template:
    metadata:
      name: "installer-test"
      labels:
        app.kubernetes.io/managed-by: "Helm"
        app.kubernetes.io/instance: "installer"
        helm.sh/chart: "rhtap-0.9.4"
    spec:
      containers:
                
        - name: test-namespace
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
        
              pipeline_id="$(cat << EOF | kubectl create -f - | cut -d' ' -f 1
                      
                apiVersion: tekton.dev/v1
                kind: PipelineRun
                metadata:
                  generateName: rhtap-test-config-
                  annotations:
                    helm.sh/chart: "rhtap-0.9.4"
                spec:
                  pipelineSpec:
                    tasks:
                    - name: acs-deploy-check
                      taskRef:
                        resolver: cluster
                        params:
                          - name: kind
                            value: task
                          - name: name
                            value: acs-deploy-check
                          - name: namespace
                            value: rhtap
                      params:
                        - name: deployment_url
                          value: https://raw.githubusercontent.com/jduimovich/quarkus-1/main/argocd/components/q/base/deployment.yaml
                        - name: insecure-skip-tls-verify
                          value: true
                    - name: acs-image-check
                      taskRef:
                        resolver: cluster
                        params:
                          - name: kind
                            value: task
                          - name: name
                            value: acs-image-check
                          - name: namespace
                            value: rhtap
                      params:
                        - name: image
                          value: quay.io/team-helium/miner
                        - name: image_digest
                          value: sha256:19bffd927a8dc70be5995eeba4ede675f57eca6222329477a50d65dc06880e3c
                        - name: insecure-skip-tls-verify
                          value: true
                    - name: acs-image-scan
                      taskRef:
                        resolver: cluster
                        params:
                          - name: kind
                            value: task
                          - name: name
                            value: acs-image-scan
                          - name: namespace
                            value: rhtap
                      params:
                        - name: image
                          value: quay.io/team-helium/miner
                        - name: image_digest
                          value: sha256:19bffd927a8dc70be5995eeba4ede675f57eca6222329477a50d65dc06880e3c
                        - name: insecure-skip-tls-verify
                          value: true
                    - name: argocd-login-check
                      taskRef:
                        resolver: cluster
                        params:
                          - name: kind
                            value: task
                          - name: name
                            value: argocd-login-check
                          - name: namespace
                            value: rhtap
                
              EOF
              )"
              echo -n "* Pipeline $pipeline_id: "
              while ! kubectl get "$pipeline_id" | grep --extended-regex --quiet " False | True "; do
                echo -n "."
                sleep 2
              done
              if kubectl get "$pipeline_id" | grep --quiet " True "; then
                kubectl delete "$pipeline_id" > /dev/null
                echo "OK"
              else
                echo "Failed"
                exit 1
              fi
        
      restartPolicy: Never
      serviceAccountName: helm-manager
